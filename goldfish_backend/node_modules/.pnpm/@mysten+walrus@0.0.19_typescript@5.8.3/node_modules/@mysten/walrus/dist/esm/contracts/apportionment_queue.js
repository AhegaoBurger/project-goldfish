import { bcs } from "@mysten/sui/bcs";
import * as uq64_64 from "./deps/0x0000000000000000000000000000000000000000000000000000000000000001/uq64_64.js";
import { normalizeMoveArguments } from "./utils/index.js";
function ApportionmentQueue(...typeParameters) {
  return bcs.struct("ApportionmentQueue", {
    entries: bcs.vector(Entry(typeParameters[0]))
  });
}
function Entry(...typeParameters) {
  return bcs.struct("Entry", {
    priority: uq64_64.UQ64_64(),
    tie_breaker: bcs.u64(),
    value: typeParameters[0]
  });
}
function init(packageAddress) {
  function _new(options) {
    const argumentsTypes = [];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "apportionment_queue",
      function: "new",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes),
      typeArguments: options.typeArguments
    });
  }
  function pop_max(options) {
    const argumentsTypes = [
      `${packageAddress}::apportionment_queue::ApportionmentQueue<${options.typeArguments[0]}>`
    ];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "apportionment_queue",
      function: "pop_max",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes),
      typeArguments: options.typeArguments
    });
  }
  function insert(options) {
    const argumentsTypes = [
      `${packageAddress}::apportionment_queue::ApportionmentQueue<${options.typeArguments[0]}>`,
      "0x0000000000000000000000000000000000000000000000000000000000000001::uq64_64::UQ64_64",
      "u64",
      `${options.typeArguments[0]}`
    ];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "apportionment_queue",
      function: "insert",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes),
      typeArguments: options.typeArguments
    });
  }
  function bubble_down(options) {
    const argumentsTypes = [
      `vector<${packageAddress}::apportionment_queue::Entry<${options.typeArguments[0]}>>`
    ];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "apportionment_queue",
      function: "bubble_down",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes),
      typeArguments: options.typeArguments
    });
  }
  function bubble_up(options) {
    const argumentsTypes = [
      `vector<${packageAddress}::apportionment_queue::Entry<${options.typeArguments[0]}>>`
    ];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "apportionment_queue",
      function: "bubble_up",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes),
      typeArguments: options.typeArguments
    });
  }
  function higher_priority_than(options) {
    const argumentsTypes = [
      `${packageAddress}::apportionment_queue::Entry<${options.typeArguments[0]}>`,
      `${packageAddress}::apportionment_queue::Entry<${options.typeArguments[0]}>`
    ];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "apportionment_queue",
      function: "higher_priority_than",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes),
      typeArguments: options.typeArguments
    });
  }
  return { _new, pop_max, insert, bubble_down, bubble_up, higher_priority_than };
}
export {
  ApportionmentQueue,
  Entry,
  init
};
//# sourceMappingURL=apportionment_queue.js.map
