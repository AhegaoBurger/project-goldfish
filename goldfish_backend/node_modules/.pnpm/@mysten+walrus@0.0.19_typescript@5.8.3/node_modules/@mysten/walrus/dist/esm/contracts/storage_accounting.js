import { bcs } from "@mysten/sui/bcs";
import * as balance from "./deps/0x0000000000000000000000000000000000000000000000000000000000000002/balance.js";
import { normalizeMoveArguments } from "./utils/index.js";
function FutureAccounting() {
  return bcs.struct("FutureAccounting", {
    epoch: bcs.u32(),
    used_capacity: bcs.u64(),
    rewards_to_distribute: balance.Balance()
  });
}
function FutureAccountingRingBuffer() {
  return bcs.struct("FutureAccountingRingBuffer", {
    current_index: bcs.u32(),
    length: bcs.u32(),
    ring_buffer: bcs.vector(FutureAccounting())
  });
}
function init(packageAddress) {
  function new_future_accounting(options) {
    const argumentsTypes = [
      "u32",
      "u64",
      `0x0000000000000000000000000000000000000000000000000000000000000002::balance::Balance<${packageAddress}::wal::WAL>`
    ];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "storage_accounting",
      function: "new_future_accounting",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  function epoch(options) {
    const argumentsTypes = [`${packageAddress}::storage_accounting::FutureAccounting`];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "storage_accounting",
      function: "epoch",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  function used_capacity(options) {
    const argumentsTypes = [`${packageAddress}::storage_accounting::FutureAccounting`];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "storage_accounting",
      function: "used_capacity",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  function increase_used_capacity(options) {
    const argumentsTypes = [`${packageAddress}::storage_accounting::FutureAccounting`, "u64"];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "storage_accounting",
      function: "increase_used_capacity",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  function rewards_balance(options) {
    const argumentsTypes = [`${packageAddress}::storage_accounting::FutureAccounting`];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "storage_accounting",
      function: "rewards_balance",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  function delete_empty_future_accounting(options) {
    const argumentsTypes = [`${packageAddress}::storage_accounting::FutureAccounting`];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "storage_accounting",
      function: "delete_empty_future_accounting",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  function unwrap_balance(options) {
    const argumentsTypes = [`${packageAddress}::storage_accounting::FutureAccounting`];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "storage_accounting",
      function: "unwrap_balance",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  function ring_new(options) {
    const argumentsTypes = ["u32"];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "storage_accounting",
      function: "ring_new",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  function ring_lookup_mut(options) {
    const argumentsTypes = [
      `${packageAddress}::storage_accounting::FutureAccountingRingBuffer`,
      "u32"
    ];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "storage_accounting",
      function: "ring_lookup_mut",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  function ring_pop_expand(options) {
    const argumentsTypes = [`${packageAddress}::storage_accounting::FutureAccountingRingBuffer`];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "storage_accounting",
      function: "ring_pop_expand",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  function max_epochs_ahead(options) {
    const argumentsTypes = [`${packageAddress}::storage_accounting::FutureAccountingRingBuffer`];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "storage_accounting",
      function: "max_epochs_ahead",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  return {
    new_future_accounting,
    epoch,
    used_capacity,
    increase_used_capacity,
    rewards_balance,
    delete_empty_future_accounting,
    unwrap_balance,
    ring_new,
    ring_lookup_mut,
    ring_pop_expand,
    max_epochs_ahead
  };
}
export {
  FutureAccounting,
  FutureAccountingRingBuffer,
  init
};
//# sourceMappingURL=storage_accounting.js.map
