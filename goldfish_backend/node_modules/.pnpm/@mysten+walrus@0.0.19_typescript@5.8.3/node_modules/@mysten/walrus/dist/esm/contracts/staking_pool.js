import { bcs } from "@mysten/sui/bcs";
import * as auth from "./auth.js";
import * as bag from "./deps/0x0000000000000000000000000000000000000000000000000000000000000002/bag.js";
import * as balance from "./deps/0x0000000000000000000000000000000000000000000000000000000000000002/balance.js";
import * as object from "./deps/0x0000000000000000000000000000000000000000000000000000000000000002/object.js";
import * as table from "./deps/0x0000000000000000000000000000000000000000000000000000000000000002/table.js";
import * as pending_values from "./pending_values.js";
import * as storage_node from "./storage_node.js";
import { normalizeMoveArguments } from "./utils/index.js";
function VotingParams() {
  return bcs.struct("VotingParams", {
    storage_price: bcs.u64(),
    write_price: bcs.u64(),
    node_capacity: bcs.u64()
  });
}
function StakingPool() {
  return bcs.struct("StakingPool", {
    id: object.UID(),
    state: PoolState(),
    voting_params: VotingParams(),
    node_info: storage_node.StorageNodeInfo(),
    activation_epoch: bcs.u32(),
    latest_epoch: bcs.u32(),
    wal_balance: bcs.u64(),
    num_shares: bcs.u64(),
    pending_shares_withdraw: pending_values.PendingValues(),
    pre_active_withdrawals: pending_values.PendingValues(),
    pending_commission_rate: pending_values.PendingValues(),
    commission_rate: bcs.u16(),
    exchange_rates: table.Table(),
    pending_stake: pending_values.PendingValues(),
    rewards_pool: balance.Balance(),
    commission: balance.Balance(),
    commission_receiver: auth.Authorized(),
    governance_authorized: auth.Authorized(),
    extra_fields: bag.Bag()
  });
}
function PoolState() {
  return bcs.enum("PoolState", {
    Active: null,
    Withdrawing: bcs.u32(),
    Withdrawn: null
  });
}
function init(packageAddress) {
  function _new(options) {
    const argumentsTypes = [
      "0x0000000000000000000000000000000000000000000000000000000000000001::string::String",
      "0x0000000000000000000000000000000000000000000000000000000000000001::string::String",
      `${packageAddress}::node_metadata::NodeMetadata`,
      "vector<u8>",
      "vector<u8>",
      "vector<u8>",
      "u16",
      "u64",
      "u64",
      "u64",
      `${packageAddress}::walrus_context::WalrusContext`
    ];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "new",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  function set_withdrawing(options) {
    const argumentsTypes = [
      `${packageAddress}::staking_pool::StakingPool`,
      `${packageAddress}::walrus_context::WalrusContext`
    ];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "set_withdrawing",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  function stake(options) {
    const argumentsTypes = [
      `${packageAddress}::staking_pool::StakingPool`,
      `0x0000000000000000000000000000000000000000000000000000000000000002::balance::Balance<${packageAddress}::wal::WAL>`,
      `${packageAddress}::walrus_context::WalrusContext`
    ];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "stake",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  function request_withdraw_stake(options) {
    const argumentsTypes = [
      `${packageAddress}::staking_pool::StakingPool`,
      `${packageAddress}::staked_wal::StakedWal`,
      "bool",
      "bool",
      `${packageAddress}::walrus_context::WalrusContext`
    ];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "request_withdraw_stake",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  function withdraw_stake(options) {
    const argumentsTypes = [
      `${packageAddress}::staking_pool::StakingPool`,
      `${packageAddress}::staked_wal::StakedWal`,
      "bool",
      "bool",
      `${packageAddress}::walrus_context::WalrusContext`
    ];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "withdraw_stake",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  function advance_epoch(options) {
    const argumentsTypes = [
      `${packageAddress}::staking_pool::StakingPool`,
      `0x0000000000000000000000000000000000000000000000000000000000000002::balance::Balance<${packageAddress}::wal::WAL>`,
      `${packageAddress}::walrus_context::WalrusContext`
    ];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "advance_epoch",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  function process_pending_stake(options) {
    const argumentsTypes = [
      `${packageAddress}::staking_pool::StakingPool`,
      `${packageAddress}::walrus_context::WalrusContext`
    ];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "process_pending_stake",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  function set_next_commission(options) {
    const argumentsTypes = [
      `${packageAddress}::staking_pool::StakingPool`,
      "u16",
      `${packageAddress}::walrus_context::WalrusContext`
    ];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "set_next_commission",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  function set_next_storage_price(options) {
    const argumentsTypes = [`${packageAddress}::staking_pool::StakingPool`, "u64"];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "set_next_storage_price",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  function set_next_write_price(options) {
    const argumentsTypes = [`${packageAddress}::staking_pool::StakingPool`, "u64"];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "set_next_write_price",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  function set_next_node_capacity(options) {
    const argumentsTypes = [`${packageAddress}::staking_pool::StakingPool`, "u64"];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "set_next_node_capacity",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  function set_next_public_key(options) {
    const argumentsTypes = [
      `${packageAddress}::staking_pool::StakingPool`,
      "vector<u8>",
      "vector<u8>",
      `${packageAddress}::walrus_context::WalrusContext`
    ];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "set_next_public_key",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  function set_name(options) {
    const argumentsTypes = [
      `${packageAddress}::staking_pool::StakingPool`,
      "0x0000000000000000000000000000000000000000000000000000000000000001::string::String"
    ];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "set_name",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  function set_network_address(options) {
    const argumentsTypes = [
      `${packageAddress}::staking_pool::StakingPool`,
      "0x0000000000000000000000000000000000000000000000000000000000000001::string::String"
    ];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "set_network_address",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  function set_network_public_key(options) {
    const argumentsTypes = [`${packageAddress}::staking_pool::StakingPool`, "vector<u8>"];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "set_network_public_key",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  function set_node_metadata(options) {
    const argumentsTypes = [
      `${packageAddress}::staking_pool::StakingPool`,
      `${packageAddress}::node_metadata::NodeMetadata`
    ];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "set_node_metadata",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  function destroy_empty(options) {
    const argumentsTypes = [`${packageAddress}::staking_pool::StakingPool`];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "destroy_empty",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  function exchange_rate_at_epoch(options) {
    const argumentsTypes = [`${packageAddress}::staking_pool::StakingPool`, "u32"];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "exchange_rate_at_epoch",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  function wal_balance_at_epoch(options) {
    const argumentsTypes = [`${packageAddress}::staking_pool::StakingPool`, "u32"];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "wal_balance_at_epoch",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  function governance_authorized(options) {
    const argumentsTypes = [`${packageAddress}::staking_pool::StakingPool`];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "governance_authorized",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  function set_governance_authorized(options) {
    const argumentsTypes = [
      `${packageAddress}::staking_pool::StakingPool`,
      `${packageAddress}::auth::Authenticated`,
      `${packageAddress}::auth::Authorized`
    ];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "set_governance_authorized",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  function commission_receiver(options) {
    const argumentsTypes = [`${packageAddress}::staking_pool::StakingPool`];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "commission_receiver",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  function set_commission_receiver(options) {
    const argumentsTypes = [
      `${packageAddress}::staking_pool::StakingPool`,
      `${packageAddress}::auth::Authenticated`,
      `${packageAddress}::auth::Authorized`
    ];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "set_commission_receiver",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  function commission_rate(options) {
    const argumentsTypes = [`${packageAddress}::staking_pool::StakingPool`];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "commission_rate",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  function commission_amount(options) {
    const argumentsTypes = [`${packageAddress}::staking_pool::StakingPool`];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "commission_amount",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  function collect_commission(options) {
    const argumentsTypes = [
      `${packageAddress}::staking_pool::StakingPool`,
      `${packageAddress}::auth::Authenticated`
    ];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "collect_commission",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  function rewards_amount(options) {
    const argumentsTypes = [`${packageAddress}::staking_pool::StakingPool`];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "rewards_amount",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  function wal_balance(options) {
    const argumentsTypes = [`${packageAddress}::staking_pool::StakingPool`];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "wal_balance",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  function storage_price(options) {
    const argumentsTypes = [`${packageAddress}::staking_pool::StakingPool`];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "storage_price",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  function write_price(options) {
    const argumentsTypes = [`${packageAddress}::staking_pool::StakingPool`];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "write_price",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  function node_capacity(options) {
    const argumentsTypes = [`${packageAddress}::staking_pool::StakingPool`];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "node_capacity",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  function activation_epoch(options) {
    const argumentsTypes = [`${packageAddress}::staking_pool::StakingPool`];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "activation_epoch",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  function node_info(options) {
    const argumentsTypes = [`${packageAddress}::staking_pool::StakingPool`];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "node_info",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  function is_active(options) {
    const argumentsTypes = [`${packageAddress}::staking_pool::StakingPool`];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "is_active",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  function is_withdrawing(options) {
    const argumentsTypes = [`${packageAddress}::staking_pool::StakingPool`];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "is_withdrawing",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  function is_empty(options) {
    const argumentsTypes = [`${packageAddress}::staking_pool::StakingPool`];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "is_empty",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  function calculate_rewards(options) {
    const argumentsTypes = [`${packageAddress}::staking_pool::StakingPool`, "u64", "u32", "u32"];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "calculate_rewards",
      arguments: normalizeMoveArguments(options.arguments, argumentsTypes)
    });
  }
  return {
    _new,
    set_withdrawing,
    stake,
    request_withdraw_stake,
    withdraw_stake,
    advance_epoch,
    process_pending_stake,
    set_next_commission,
    set_next_storage_price,
    set_next_write_price,
    set_next_node_capacity,
    set_next_public_key,
    set_name,
    set_network_address,
    set_network_public_key,
    set_node_metadata,
    destroy_empty,
    exchange_rate_at_epoch,
    wal_balance_at_epoch,
    governance_authorized,
    set_governance_authorized,
    commission_receiver,
    set_commission_receiver,
    commission_rate,
    commission_amount,
    collect_commission,
    rewards_amount,
    wal_balance,
    storage_price,
    write_price,
    node_capacity,
    activation_epoch,
    node_info,
    is_active,
    is_withdrawing,
    is_empty,
    calculate_rewards
  };
}
export {
  PoolState,
  StakingPool,
  VotingParams,
  init
};
//# sourceMappingURL=staking_pool.js.map
