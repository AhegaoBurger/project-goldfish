"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var staking_pool_exports = {};
__export(staking_pool_exports, {
  PoolState: () => PoolState,
  StakingPool: () => StakingPool,
  VotingParams: () => VotingParams,
  init: () => init
});
module.exports = __toCommonJS(staking_pool_exports);
var import_bcs = require("@mysten/sui/bcs");
var auth = __toESM(require("./auth.js"));
var bag = __toESM(require("./deps/0x0000000000000000000000000000000000000000000000000000000000000002/bag.js"));
var balance = __toESM(require("./deps/0x0000000000000000000000000000000000000000000000000000000000000002/balance.js"));
var object = __toESM(require("./deps/0x0000000000000000000000000000000000000000000000000000000000000002/object.js"));
var table = __toESM(require("./deps/0x0000000000000000000000000000000000000000000000000000000000000002/table.js"));
var pending_values = __toESM(require("./pending_values.js"));
var storage_node = __toESM(require("./storage_node.js"));
var import_utils = require("./utils/index.js");
function VotingParams() {
  return import_bcs.bcs.struct("VotingParams", {
    storage_price: import_bcs.bcs.u64(),
    write_price: import_bcs.bcs.u64(),
    node_capacity: import_bcs.bcs.u64()
  });
}
function StakingPool() {
  return import_bcs.bcs.struct("StakingPool", {
    id: object.UID(),
    state: PoolState(),
    voting_params: VotingParams(),
    node_info: storage_node.StorageNodeInfo(),
    activation_epoch: import_bcs.bcs.u32(),
    latest_epoch: import_bcs.bcs.u32(),
    wal_balance: import_bcs.bcs.u64(),
    num_shares: import_bcs.bcs.u64(),
    pending_shares_withdraw: pending_values.PendingValues(),
    pre_active_withdrawals: pending_values.PendingValues(),
    pending_commission_rate: pending_values.PendingValues(),
    commission_rate: import_bcs.bcs.u16(),
    exchange_rates: table.Table(),
    pending_stake: pending_values.PendingValues(),
    rewards_pool: balance.Balance(),
    commission: balance.Balance(),
    commission_receiver: auth.Authorized(),
    governance_authorized: auth.Authorized(),
    extra_fields: bag.Bag()
  });
}
function PoolState() {
  return import_bcs.bcs.enum("PoolState", {
    Active: null,
    Withdrawing: import_bcs.bcs.u32(),
    Withdrawn: null
  });
}
function init(packageAddress) {
  function _new(options) {
    const argumentsTypes = [
      "0x0000000000000000000000000000000000000000000000000000000000000001::string::String",
      "0x0000000000000000000000000000000000000000000000000000000000000001::string::String",
      `${packageAddress}::node_metadata::NodeMetadata`,
      "vector<u8>",
      "vector<u8>",
      "vector<u8>",
      "u16",
      "u64",
      "u64",
      "u64",
      `${packageAddress}::walrus_context::WalrusContext`
    ];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "new",
      arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes)
    });
  }
  function set_withdrawing(options) {
    const argumentsTypes = [
      `${packageAddress}::staking_pool::StakingPool`,
      `${packageAddress}::walrus_context::WalrusContext`
    ];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "set_withdrawing",
      arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes)
    });
  }
  function stake(options) {
    const argumentsTypes = [
      `${packageAddress}::staking_pool::StakingPool`,
      `0x0000000000000000000000000000000000000000000000000000000000000002::balance::Balance<${packageAddress}::wal::WAL>`,
      `${packageAddress}::walrus_context::WalrusContext`
    ];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "stake",
      arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes)
    });
  }
  function request_withdraw_stake(options) {
    const argumentsTypes = [
      `${packageAddress}::staking_pool::StakingPool`,
      `${packageAddress}::staked_wal::StakedWal`,
      "bool",
      "bool",
      `${packageAddress}::walrus_context::WalrusContext`
    ];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "request_withdraw_stake",
      arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes)
    });
  }
  function withdraw_stake(options) {
    const argumentsTypes = [
      `${packageAddress}::staking_pool::StakingPool`,
      `${packageAddress}::staked_wal::StakedWal`,
      "bool",
      "bool",
      `${packageAddress}::walrus_context::WalrusContext`
    ];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "withdraw_stake",
      arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes)
    });
  }
  function advance_epoch(options) {
    const argumentsTypes = [
      `${packageAddress}::staking_pool::StakingPool`,
      `0x0000000000000000000000000000000000000000000000000000000000000002::balance::Balance<${packageAddress}::wal::WAL>`,
      `${packageAddress}::walrus_context::WalrusContext`
    ];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "advance_epoch",
      arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes)
    });
  }
  function process_pending_stake(options) {
    const argumentsTypes = [
      `${packageAddress}::staking_pool::StakingPool`,
      `${packageAddress}::walrus_context::WalrusContext`
    ];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "process_pending_stake",
      arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes)
    });
  }
  function set_next_commission(options) {
    const argumentsTypes = [
      `${packageAddress}::staking_pool::StakingPool`,
      "u16",
      `${packageAddress}::walrus_context::WalrusContext`
    ];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "set_next_commission",
      arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes)
    });
  }
  function set_next_storage_price(options) {
    const argumentsTypes = [`${packageAddress}::staking_pool::StakingPool`, "u64"];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "set_next_storage_price",
      arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes)
    });
  }
  function set_next_write_price(options) {
    const argumentsTypes = [`${packageAddress}::staking_pool::StakingPool`, "u64"];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "set_next_write_price",
      arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes)
    });
  }
  function set_next_node_capacity(options) {
    const argumentsTypes = [`${packageAddress}::staking_pool::StakingPool`, "u64"];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "set_next_node_capacity",
      arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes)
    });
  }
  function set_next_public_key(options) {
    const argumentsTypes = [
      `${packageAddress}::staking_pool::StakingPool`,
      "vector<u8>",
      "vector<u8>",
      `${packageAddress}::walrus_context::WalrusContext`
    ];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "set_next_public_key",
      arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes)
    });
  }
  function set_name(options) {
    const argumentsTypes = [
      `${packageAddress}::staking_pool::StakingPool`,
      "0x0000000000000000000000000000000000000000000000000000000000000001::string::String"
    ];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "set_name",
      arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes)
    });
  }
  function set_network_address(options) {
    const argumentsTypes = [
      `${packageAddress}::staking_pool::StakingPool`,
      "0x0000000000000000000000000000000000000000000000000000000000000001::string::String"
    ];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "set_network_address",
      arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes)
    });
  }
  function set_network_public_key(options) {
    const argumentsTypes = [`${packageAddress}::staking_pool::StakingPool`, "vector<u8>"];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "set_network_public_key",
      arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes)
    });
  }
  function set_node_metadata(options) {
    const argumentsTypes = [
      `${packageAddress}::staking_pool::StakingPool`,
      `${packageAddress}::node_metadata::NodeMetadata`
    ];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "set_node_metadata",
      arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes)
    });
  }
  function destroy_empty(options) {
    const argumentsTypes = [`${packageAddress}::staking_pool::StakingPool`];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "destroy_empty",
      arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes)
    });
  }
  function exchange_rate_at_epoch(options) {
    const argumentsTypes = [`${packageAddress}::staking_pool::StakingPool`, "u32"];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "exchange_rate_at_epoch",
      arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes)
    });
  }
  function wal_balance_at_epoch(options) {
    const argumentsTypes = [`${packageAddress}::staking_pool::StakingPool`, "u32"];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "wal_balance_at_epoch",
      arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes)
    });
  }
  function governance_authorized(options) {
    const argumentsTypes = [`${packageAddress}::staking_pool::StakingPool`];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "governance_authorized",
      arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes)
    });
  }
  function set_governance_authorized(options) {
    const argumentsTypes = [
      `${packageAddress}::staking_pool::StakingPool`,
      `${packageAddress}::auth::Authenticated`,
      `${packageAddress}::auth::Authorized`
    ];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "set_governance_authorized",
      arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes)
    });
  }
  function commission_receiver(options) {
    const argumentsTypes = [`${packageAddress}::staking_pool::StakingPool`];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "commission_receiver",
      arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes)
    });
  }
  function set_commission_receiver(options) {
    const argumentsTypes = [
      `${packageAddress}::staking_pool::StakingPool`,
      `${packageAddress}::auth::Authenticated`,
      `${packageAddress}::auth::Authorized`
    ];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "set_commission_receiver",
      arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes)
    });
  }
  function commission_rate(options) {
    const argumentsTypes = [`${packageAddress}::staking_pool::StakingPool`];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "commission_rate",
      arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes)
    });
  }
  function commission_amount(options) {
    const argumentsTypes = [`${packageAddress}::staking_pool::StakingPool`];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "commission_amount",
      arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes)
    });
  }
  function collect_commission(options) {
    const argumentsTypes = [
      `${packageAddress}::staking_pool::StakingPool`,
      `${packageAddress}::auth::Authenticated`
    ];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "collect_commission",
      arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes)
    });
  }
  function rewards_amount(options) {
    const argumentsTypes = [`${packageAddress}::staking_pool::StakingPool`];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "rewards_amount",
      arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes)
    });
  }
  function wal_balance(options) {
    const argumentsTypes = [`${packageAddress}::staking_pool::StakingPool`];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "wal_balance",
      arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes)
    });
  }
  function storage_price(options) {
    const argumentsTypes = [`${packageAddress}::staking_pool::StakingPool`];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "storage_price",
      arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes)
    });
  }
  function write_price(options) {
    const argumentsTypes = [`${packageAddress}::staking_pool::StakingPool`];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "write_price",
      arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes)
    });
  }
  function node_capacity(options) {
    const argumentsTypes = [`${packageAddress}::staking_pool::StakingPool`];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "node_capacity",
      arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes)
    });
  }
  function activation_epoch(options) {
    const argumentsTypes = [`${packageAddress}::staking_pool::StakingPool`];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "activation_epoch",
      arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes)
    });
  }
  function node_info(options) {
    const argumentsTypes = [`${packageAddress}::staking_pool::StakingPool`];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "node_info",
      arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes)
    });
  }
  function is_active(options) {
    const argumentsTypes = [`${packageAddress}::staking_pool::StakingPool`];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "is_active",
      arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes)
    });
  }
  function is_withdrawing(options) {
    const argumentsTypes = [`${packageAddress}::staking_pool::StakingPool`];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "is_withdrawing",
      arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes)
    });
  }
  function is_empty(options) {
    const argumentsTypes = [`${packageAddress}::staking_pool::StakingPool`];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "is_empty",
      arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes)
    });
  }
  function calculate_rewards(options) {
    const argumentsTypes = [`${packageAddress}::staking_pool::StakingPool`, "u64", "u32", "u32"];
    return (tx) => tx.moveCall({
      package: packageAddress,
      module: "staking_pool",
      function: "calculate_rewards",
      arguments: (0, import_utils.normalizeMoveArguments)(options.arguments, argumentsTypes)
    });
  }
  return {
    _new,
    set_withdrawing,
    stake,
    request_withdraw_stake,
    withdraw_stake,
    advance_epoch,
    process_pending_stake,
    set_next_commission,
    set_next_storage_price,
    set_next_write_price,
    set_next_node_capacity,
    set_next_public_key,
    set_name,
    set_network_address,
    set_network_public_key,
    set_node_metadata,
    destroy_empty,
    exchange_rate_at_epoch,
    wal_balance_at_epoch,
    governance_authorized,
    set_governance_authorized,
    commission_receiver,
    set_commission_receiver,
    commission_rate,
    commission_amount,
    collect_commission,
    rewards_amount,
    wal_balance,
    storage_price,
    write_price,
    node_capacity,
    activation_epoch,
    node_info,
    is_active,
    is_withdrawing,
    is_empty,
    calculate_rewards
  };
}
//# sourceMappingURL=staking_pool.js.map
